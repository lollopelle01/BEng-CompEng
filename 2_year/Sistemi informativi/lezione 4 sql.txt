SET CURRENT SCHEMA syscat;

--q1) Determinare per ogni table (TYPE = ‘T’) , il numero di foreign key, 
--ignorando quelle autoreferenziali (ed escludendo le tabelle con 0 foreign key) e 
--ordinare per valori decrescenti (a parità, per nome di schema e di tabella)
SELECT t.TABSCHEMA , t.TABNAME , t.PARENTS-t.SELFREFS AS numFK
FROM TABLES t 
WHERE LOWER(t."TYPE") = 't' 
	AND t.PARENTS >0
ORDER BY numFK DESC, t.TABSCHEMA , t.TABNAME;

--q2) Mostrare gli schemi con almeno 5 table o view, ordinando in senso decrescente per numero totale di oggetti
SELECT t.TABSCHEMA, count(*) AS numTabView
FROM TABLES t 
WHERE t."TYPE" = 'T' OR t."TYPE" = 'V'
GROUP BY t.TABSCHEMA
HAVING count(*)>=5
ORDER BY numTabView DESC;

--q3) Per ogni vista di SYSCAT, determinare da quanti oggetti di ciascun tipo dipende
SELECT t.TABNAME, t.BTYPE, count(*) AS dip
FROM TABDEP t 
WHERE t.TABSCHEMA ='SYSCAT'
GROUP BY t.TABNAME, t.BTYPE;

--q4) Senza usare l’attributo TABLES.COLCOUNT, né viste, 
--determinare la table (TYPE = ‘T’) con il maggior numero di colonne
SELECT t.TABSCHEMA, t.TABNAME, count(*) AS numCol
FROM TABLES t JOIN COLUMNS c ON (t.TABSCHEMA=c.TABSCHEMA AND t.TABNAME=c.TABNAME)
WHERE t."TYPE" ='T'
GROUP BY t.TABSCHEMA, t.TABNAME 
HAVING count(*) >= all(
	SELECT count(*)
	FROM TABLES t1 JOIN COLUMNS c1 ON (t1.TABSCHEMA=c1.TABSCHEMA AND t1.TABNAME=c1.TABNAME)
	WHERE t1."TYPE" ='T'
	GROUP BY t1.TABSCHEMA, t1.TABNAME 
);

--q5) Per ogni tipo di dato (COLUMNS.TYPENAME), il n. di oggetti in cui quel tipo è il più usato
WITH	
	TYPECOUNT(SCHEMA,TABLE,TYPE,NUM) 
	AS (	
		SELECT	 TABSCHEMA, TABNAME, TYPENAME, COUNT(*)
		FROM	 SYSCAT.COLUMNS
		GROUP BY TABSCHEMA, TABNAME, TYPENAME
		),
	TYPEWINS(SCHEMA,TABLE,TYPE) -- il tipo piu' frequente in una table; SCHEMA e TABLE non sono necessari in output
	AS (	
		SELECT 	T.SCHEMA, T.TABLE, T.TYPE
		FROM 	TYPECOUNT T
		WHERE 	T.NUM >= ALL 
		    (	SELECT 	T1.NUM 
				FROM 	TYPECOUNT T1 
				WHERE (T1.SCHEMA,T1.TABLE) = (T.SCHEMA,T.TABLE)	
			)  
		)
SELECT	 TYPE, COUNT(*) AS NUM_TABLES
FROM 	 TYPEWINS
GROUP BY TYPE
ORDER BY NUM_TABLES DESC ;

--q6) La coppia di nomi di table che compaiono più frequentemente insieme in uno stesso schema
WITH 
	STESSO_SCHEMA(TABNAME1, TABNAME2, NUM)
	AS (
		SELECT DISTINCT t1.TABNAME, t2.TABNAME, count(*) AS num
		FROM TABLES t1 JOIN TABLES t2 ON(t1.TABNAME<t2.TABNAME AND t1.TABSCHEMA=t2.TABSCHEMA)
		WHERE (t1."TYPE", t2."TYPE")=('T', 'T')
		GROUP BY t1.TABNAME, t2.TABNAME 
		ORDER BY num
		)
SELECT *
FROM stesso_schema s
GROUP BY s.TABNAME1, s.TABNAME2, s.NUM
HAVING s.NUM>=all(
	SELECT s1.num
	FROM stesso_schema s1
);

--q7) Determinare il nome di table più “popolare” su SIT_STUD, fornendo il nome e i timestamp di creazione minimo e massimo
WITH 
	TAVOLE(TABNAME, TIME_MIN, TIME_MAX, NUM)
	AS (
			SELECT t.TABNAME , MIN(t.CREATE_TIME), MAX(t.CREATE_TIME), count(*) AS num
			FROM TABLES t
			WHERE t."TYPE"='T'
			GROUP BY t.TABNAME
		)
SELECT tav.TABNAME, tav.TIME_MIN, tav.TIME_MAX
FROM TAVOLE tav
GROUP BY tav.TABNAME, tav.TIME_MIN, tav.TIME_MAX, tav.NUM
HAVING tav.NUM=(
	SELECT MAX(t1.NUM)
	FROM TAVOLE t1
);

--ESERCIZIO 2
--view 1) per ogni table o view nel proprio schema mostra il numero di (altre) table o view con lo stesso nome nel DB SIT_STUD create prima (SAMEBEFORE) e dopo (SAMEAFTER).

/*WITH 
	PRIMA(TABNAME, NUM)
	AS(
		SELECT DISTINCT T1.TABNAME, COUNT(*) AS NUM
		FROM TABLES T1 JOIN TABLES T2 ON(T1.TABNAME=T2.TABNAME AND T1.CREATE_TIME<=T2.CREATE_TIME)
		WHERE ((T1."TYPE", T2."TYPE")=('V', 'V') OR (T1."TYPE", T2."TYPE")=('T', 'T'))
			AND T1.TABSCHEMA=CURRENTUSER
		GROUP BY T1.TABNAME
	),
	DOPO(TABNAME, NUM)
	AS(
		SELECT DISTINCT T1.TABNAME, COUNT(*) AS NUM
		FROM TABLES T1 JOIN TABLES T2 ON(T1.TABNAME=T2.TABNAME AND T1.CREATE_TIME>=T2.CREATE_TIME)
		WHERE ((T1."TYPE", T2."TYPE")=('V', 'V') OR (T1."TYPE", T2."TYPE")=('T', 'T'))
			AND T1.TABSCHEMA=CURRENTUSER
		GROUP BY T1.TABNAME
	)
	*/

CREATE OR REPLACE VIEW CAT_SAMENAME (TABNAME,SAMEBEFORE,SAMEAFTER)
AS(
	SELECT P.TABNAME, P.NUM, D.NUM
	FROM (	SELECT DISTINCT T1.TABNAME, COUNT(*) AS NUM
			FROM SYSCAT.TABLES T1 JOIN SYSCAT.TABLES T2 ON(T1.TABNAME=T2.TABNAME AND T1.CREATE_TIME>=T2.CREATE_TIME)
			WHERE ((T1."TYPE", T2."TYPE")=('V', 'V') OR (T1."TYPE", T2."TYPE")=('T', 'T'))
				AND T1.TABSCHEMA=CURRENT USER
			GROUP BY T1.TABNAME) AS P 
		JOIN 
		(	SELECT DISTINCT T1.TABNAME, COUNT(*) AS NUM
			FROM SYSCAT.TABLES T1 JOIN SYSCAT.TABLES T2 ON(T1.TABNAME=T2.TABNAME AND T1.CREATE_TIME>=T2.CREATE_TIME)
			WHERE ((T1."TYPE", T2."TYPE")=('V', 'V') OR (T1."TYPE", T2."TYPE")=('T', 'T'))
				AND T1.TABSCHEMA=CURRENT USER
			GROUP BY T1.TABNAME) AS D
		ON (P.TABNAME=D.TABNAME)
);

--view 2) il catalogo, per ogni table o view del proprio schema e definita con lo stesso nome anche in altri schemi, 
--mostra le eventuali differenze esistenti sui nomi degli attributi definiti.
CREATE OR REPLACE VIEW CAT_TABDIFF(MYTABLE, YOURSCHEMA, DIFFCOLUMN, DIFF) 
AS 	
	SELECT	DISTINCT M.TABNAME, Y.TABSCHEMA, M.COLNAME, '-'
	FROM 	COLUMNS M, COLUMNS Y
	WHERE 	M.TABSCHEMA = CURRENT USER
	AND	Y.TABSCHEMA <> M.TABSCHEMA
	AND 	M.TABNAME = Y.TABNAME
	AND	NOT EXISTS
				(SELECT *
			     FROM   COLUMNS Y2
			     WHERE  Y2.COLNAME = M.COLNAME
			     AND    Y2.TABNAME = Y.TABNAME
			     AND    Y2.TABSCHEMA = Y.TABSCHEMA)
    UNION ALL
    
	SELECT	DISTINCT M.TABNAME, Y.TABSCHEMA, Y.COLNAME, '+'
	FROM 	COLUMNS M, COLUMNS Y
	WHERE 	M.TABSCHEMA = CURRENT USER
	AND	Y.TABSCHEMA <> M.TABSCHEMA
	AND 	M.TABNAME = Y.TABNAME
	AND	NOT EXISTS
				(SELECT *
			     FROM   COLUMNS Y2
			     WHERE  Y2.COLNAME = Y.COLNAME
			     AND    Y2.TABNAME = M.TABNAME
			     AND    Y2.TABSCHEMA = M.TABSCHEMA)
;